package cn.com.sky.patterns.behavioral.visitor.model;

/**
 * 
 * <pre>
 *
 * 一、概念
 *     访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。
 *     
 *     据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。这样的过程叫做“双重分派”。节点调用访问者，将它自己传入，访问者则将某算法针对此节点执行。
 *     
 * 二、角色 
 *   访问者模式涉及到的角色如下：
 *     抽象访问者(Visitor)角色：声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。
 *     具体访问者(ConcreteVisitor)角色：实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。
 *     抽象节点(Node)角色：声明一个接受操作，接受一个访问者对象作为一个参数。
 *     具体节点(ConcreteNode)角色：实现了抽象节点所规定的接受操作。
 *     结构对象(ObjectStructure)角色：有如下的责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。
 *    
 *     在实际系统中访问者模式通常是用来处理复杂的对象树结构的，而且访问者模式可以用来处理跨越多个等级结构的树结构问题。这正是访问者模式的功能强大之处。
 *   
 *   
 *  三、优缺点 
 *  访问者模式的优点
 *  好的扩展性:能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
 *  好的复用性:可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。
 *  分离无关行为:可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。
 *   
 *  访问者模式的缺点
 *  对象结构变化很困难:不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。
 *  破坏封装:访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。　
 *   
 *   
 *   四、应用场景
 *  访问者模式的基本想法如下：首先我们拥有一个由许多对象构成的对象结构，这些对象的类都拥有一个accept方法用来接受访问者对象；
 *  访问者是一个接口，它拥有一个visit方法，这个方法对访问到的对象结构中不同类型的元素作出不同的反应；
 *  在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施accept方法，在每一个元素的accept方法中回调访问者的visit方法，从而使访问者得以处理对象结构的每一个元素。
 *  我们可以针对对象结构设计不同的实在的访问者类来完成不同的操作。
 * 
 * 
 * 访问者模式使得我们可以在传统的单分派语言（如Smalltalk、Java和C++）中模拟双分派技术。对于支持多分派的语言（如CLOS），访问者模式已经内置于语言特性之中了，从而不再重要。
 * 
 * </pre>
 */
public class Client {

	public static void main(String[] args) {
		// 创建一个结构对象
		ObjectStructure os = new ObjectStructure();
		// 给结构增加一个节点
		os.add(new NodeA());
		// 给结构增加一个节点
		os.add(new NodeB());
		// 创建一个访问者
		Visitor visitor = new VisitorA();
		os.action(visitor);
	}

}